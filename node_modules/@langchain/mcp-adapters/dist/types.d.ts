import { z } from "zod";
import type { OAuthClientProvider } from "@modelcontextprotocol/sdk/client/auth.js";
export type { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
/**
 * Zod schema for an individual content item within a CallToolResult.
 */
declare const callToolResultContentSchema: z.ZodUnion<[z.ZodObject<{
    type: z.ZodLiteral<"text">;
    text: z.ZodString;
}, "passthrough", z.ZodTypeAny, z.objectOutputType<{
    type: z.ZodLiteral<"text">;
    text: z.ZodString;
}, z.ZodTypeAny, "passthrough">, z.objectInputType<{
    type: z.ZodLiteral<"text">;
    text: z.ZodString;
}, z.ZodTypeAny, "passthrough">>, z.ZodObject<{
    type: z.ZodLiteral<"image">;
    data: z.ZodString;
    mimeType: z.ZodString;
}, "passthrough", z.ZodTypeAny, z.objectOutputType<{
    type: z.ZodLiteral<"image">;
    data: z.ZodString;
    mimeType: z.ZodString;
}, z.ZodTypeAny, "passthrough">, z.objectInputType<{
    type: z.ZodLiteral<"image">;
    data: z.ZodString;
    mimeType: z.ZodString;
}, z.ZodTypeAny, "passthrough">>, z.ZodObject<{
    type: z.ZodLiteral<"audio">;
    data: z.ZodString;
    mimeType: z.ZodString;
}, "passthrough", z.ZodTypeAny, z.objectOutputType<{
    type: z.ZodLiteral<"audio">;
    data: z.ZodString;
    mimeType: z.ZodString;
}, z.ZodTypeAny, "passthrough">, z.objectInputType<{
    type: z.ZodLiteral<"audio">;
    data: z.ZodString;
    mimeType: z.ZodString;
}, z.ZodTypeAny, "passthrough">>, z.ZodObject<{
    type: z.ZodLiteral<"resource">;
    resource: z.ZodUnion<[z.ZodObject<z.objectUtil.extendShape<{
        uri: z.ZodString;
        mimeType: z.ZodOptional<z.ZodString>;
    }, {
        text: z.ZodString;
    }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<{
        uri: z.ZodString;
        mimeType: z.ZodOptional<z.ZodString>;
    }, {
        text: z.ZodString;
    }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<{
        uri: z.ZodString;
        mimeType: z.ZodOptional<z.ZodString>;
    }, {
        text: z.ZodString;
    }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<{
        uri: z.ZodString;
        mimeType: z.ZodOptional<z.ZodString>;
    }, {
        blob: z.ZodString;
    }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<{
        uri: z.ZodString;
        mimeType: z.ZodOptional<z.ZodString>;
    }, {
        blob: z.ZodString;
    }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<{
        uri: z.ZodString;
        mimeType: z.ZodOptional<z.ZodString>;
    }, {
        blob: z.ZodString;
    }>, z.ZodTypeAny, "passthrough">>]>;
}, "passthrough", z.ZodTypeAny, z.objectOutputType<{
    type: z.ZodLiteral<"resource">;
    resource: z.ZodUnion<[z.ZodObject<z.objectUtil.extendShape<{
        uri: z.ZodString;
        mimeType: z.ZodOptional<z.ZodString>;
    }, {
        text: z.ZodString;
    }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<{
        uri: z.ZodString;
        mimeType: z.ZodOptional<z.ZodString>;
    }, {
        text: z.ZodString;
    }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<{
        uri: z.ZodString;
        mimeType: z.ZodOptional<z.ZodString>;
    }, {
        text: z.ZodString;
    }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<{
        uri: z.ZodString;
        mimeType: z.ZodOptional<z.ZodString>;
    }, {
        blob: z.ZodString;
    }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<{
        uri: z.ZodString;
        mimeType: z.ZodOptional<z.ZodString>;
    }, {
        blob: z.ZodString;
    }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<{
        uri: z.ZodString;
        mimeType: z.ZodOptional<z.ZodString>;
    }, {
        blob: z.ZodString;
    }>, z.ZodTypeAny, "passthrough">>]>;
}, z.ZodTypeAny, "passthrough">, z.objectInputType<{
    type: z.ZodLiteral<"resource">;
    resource: z.ZodUnion<[z.ZodObject<z.objectUtil.extendShape<{
        uri: z.ZodString;
        mimeType: z.ZodOptional<z.ZodString>;
    }, {
        text: z.ZodString;
    }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<{
        uri: z.ZodString;
        mimeType: z.ZodOptional<z.ZodString>;
    }, {
        text: z.ZodString;
    }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<{
        uri: z.ZodString;
        mimeType: z.ZodOptional<z.ZodString>;
    }, {
        text: z.ZodString;
    }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<{
        uri: z.ZodString;
        mimeType: z.ZodOptional<z.ZodString>;
    }, {
        blob: z.ZodString;
    }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<{
        uri: z.ZodString;
        mimeType: z.ZodOptional<z.ZodString>;
    }, {
        blob: z.ZodString;
    }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<{
        uri: z.ZodString;
        mimeType: z.ZodOptional<z.ZodString>;
    }, {
        blob: z.ZodString;
    }>, z.ZodTypeAny, "passthrough">>]>;
}, z.ZodTypeAny, "passthrough">>]>;
export type CallToolResultContent = z.output<typeof callToolResultContentSchema>;
/**
 * Zod schema for the 'type' field of a CallToolResultContent item.
 * This will be a union of literals like "text", "image", "audio", and "resource".
 */
export declare const callToolResultContentTypeSchema: z.ZodUnion<[z.ZodLiteral<"text">, z.ZodLiteral<"image">, z.ZodLiteral<"audio">, z.ZodLiteral<"resource">]>;
export type CallToolResultContentType = z.output<typeof callToolResultContentTypeSchema>;
declare const detailedOutputHandlingSchema: z.ZodObject<{
    text: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
    image: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
    audio: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
    resource: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
}, "strip", z.ZodTypeAny, {
    text?: "content" | "artifact" | undefined;
    image?: "content" | "artifact" | undefined;
    audio?: "content" | "artifact" | undefined;
    resource?: "content" | "artifact" | undefined;
}, {
    text?: "content" | "artifact" | undefined;
    image?: "content" | "artifact" | undefined;
    audio?: "content" | "artifact" | undefined;
    resource?: "content" | "artifact" | undefined;
}>;
export type DetailedOutputHandling = z.output<typeof detailedOutputHandlingSchema>;
export declare const outputHandlingSchema: z.ZodUnion<[z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>, z.ZodObject<{
    text: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
    image: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
    audio: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
    resource: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
}, "strip", z.ZodTypeAny, {
    text?: "content" | "artifact" | undefined;
    image?: "content" | "artifact" | undefined;
    audio?: "content" | "artifact" | undefined;
    resource?: "content" | "artifact" | undefined;
}, {
    text?: "content" | "artifact" | undefined;
    image?: "content" | "artifact" | undefined;
    audio?: "content" | "artifact" | undefined;
    resource?: "content" | "artifact" | undefined;
}>]>;
/**
 * Defines where to place each tool output type in the LangChain ToolMessage.
 *
 * Can be set to `content` or `artifact` to send all tool output into the ToolMessage.content or
 * ToolMessage.artifact array, respectively, or you can assign an object that maps each content type
 * to `content` or `artifact`.
 *
 * @default {
 *   "text": "content",
 *   "image": "content",
 *   "audio": "content",
 *   "resource": "artifact"
 * }
 *
 * Items in the `content` field will be used as input context for the LLM, while the artifact field is
 * used for capturing tool output that won't be shown to the model, to be used in some later workflow
 * step.
 *
 * For example, imagine that you have a SQL query tool that can return huge result sets. Rather than
 * sending these large outputs directly to the model, perhaps you want the model to be able to inspect
 * the output in a code execution environment. In this case, you would set the output handling for the
 * `resource` type to `artifact` (its default value), and then upon initialization of your code
 * execution environment, you would look through your message history for `ToolMessage`s with the
 * `artifact` field set to `resource`, and use the `content` field during initialization of the
 * environment.
 */
export type OutputHandling = z.output<typeof outputHandlingSchema>;
/**
 * Zod schema for validating OAuthClientProvider interface
 * Since OAuthClientProvider has methods, we create a custom validator
 */
export declare const oAuthClientProviderSchema: z.ZodType<OAuthClientProvider, z.ZodTypeDef, OAuthClientProvider>;
export declare const baseConfigSchema: z.ZodObject<{
    /**
     * Defines where to place each tool output type in the LangChain ToolMessage.
     *
     * Can be set to `content` or `artifact` to send all tool output into the ToolMessage.content or
     * ToolMessage.artifact array, respectively, or you can assign an object that maps each content type
     * to `content` or `artifact`.
     *
     * @default {
     *   "text": "content",
     *   "image": "content",
     *   "audio": "content",
     *   "resource": "artifact"
     * }
     *
     * Items in the `content` field will be used as input context for the LLM, while the artifact field is
     * used for capturing tool output that won't be shown to the model, to be used in some later workflow
     * step.
     *
     * For example, imagine that you have a SQL query tool that can return huge result sets. Rather than
     * sending these large outputs directly to the model, perhaps you want the model to be able to inspect
     * the output in a code execution environment. In this case, you would set the output handling for the
     * `resource` type to `artifact` (its default value), and then upon initialization of your code
     * execution environment, you would look through your message history for `ToolMessage`s with the
     * `artifact` field set to `resource`, and use the `content` field during initialization of the
     * environment.
     */
    outputHandling: z.ZodOptional<z.ZodUnion<[z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>, z.ZodObject<{
        text: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
        image: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
        audio: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
        resource: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
    }, "strip", z.ZodTypeAny, {
        text?: "content" | "artifact" | undefined;
        image?: "content" | "artifact" | undefined;
        audio?: "content" | "artifact" | undefined;
        resource?: "content" | "artifact" | undefined;
    }, {
        text?: "content" | "artifact" | undefined;
        image?: "content" | "artifact" | undefined;
        audio?: "content" | "artifact" | undefined;
        resource?: "content" | "artifact" | undefined;
    }>]>>;
    /**
     * Default timeout in milliseconds for tool execution. Must be greater than 0.
     * If not specified, tools will use their own configured timeout values.
     */
    defaultToolTimeout: z.ZodOptional<z.ZodNumber>;
}, "strip", z.ZodTypeAny, {
    outputHandling?: "content" | "artifact" | {
        text?: "content" | "artifact" | undefined;
        image?: "content" | "artifact" | undefined;
        audio?: "content" | "artifact" | undefined;
        resource?: "content" | "artifact" | undefined;
    } | undefined;
    defaultToolTimeout?: number | undefined;
}, {
    outputHandling?: "content" | "artifact" | {
        text?: "content" | "artifact" | undefined;
        image?: "content" | "artifact" | undefined;
        audio?: "content" | "artifact" | undefined;
        resource?: "content" | "artifact" | undefined;
    } | undefined;
    defaultToolTimeout?: number | undefined;
}>;
/**
 * Stdio transport restart configuration
 */
export declare const stdioRestartSchema: z.ZodObject<{
    /**
     * Whether to automatically restart the process if it exits
     */
    enabled: z.ZodOptional<z.ZodBoolean>;
    /**
     * Maximum number of restart attempts
     */
    maxAttempts: z.ZodOptional<z.ZodNumber>;
    /**
     * Delay in milliseconds between restart attempts
     */
    delayMs: z.ZodOptional<z.ZodNumber>;
}, "strip", z.ZodTypeAny, {
    enabled?: boolean | undefined;
    maxAttempts?: number | undefined;
    delayMs?: number | undefined;
}, {
    enabled?: boolean | undefined;
    maxAttempts?: number | undefined;
    delayMs?: number | undefined;
}>;
/**
 * Stdio transport connection
 */
export declare const stdioConnectionSchema: z.ZodIntersection<z.ZodObject<{
    /**
     * Optional transport type, inferred from the structure of the config if not provided. Included
     * for compatibility with common MCP client config file formats.
     */
    transport: z.ZodOptional<z.ZodLiteral<"stdio">>;
    /**
     * Optional transport type, inferred from the structure of the config if not provided. Included
     * for compatibility with common MCP client config file formats.
     */
    type: z.ZodOptional<z.ZodLiteral<"stdio">>;
    /**
     * The executable to run the server (e.g. `node`, `npx`, etc)
     */
    command: z.ZodString;
    /**
     * Array of command line arguments to pass to the executable
     */
    args: z.ZodArray<z.ZodString, "many">;
    /**
     * Environment variables to set when spawning the process.
     */
    env: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
    /**
     * The encoding to use when reading from the process
     */
    encoding: z.ZodOptional<z.ZodString>;
    /**
     * How to handle stderr of the child process. This matches the semantics of Node's `child_process.spawn`
     *
     * The default is "inherit", meaning messages to stderr will be printed to the parent process's stderr.
     *
     * @default "inherit"
     */
    stderr: z.ZodDefault<z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"overlapped">, z.ZodLiteral<"pipe">, z.ZodLiteral<"ignore">, z.ZodLiteral<"inherit">]>>>;
    /**
     * The working directory to use when spawning the process.
     */
    cwd: z.ZodOptional<z.ZodString>;
    /**
     * Additional restart settings
     */
    restart: z.ZodOptional<z.ZodObject<{
        /**
         * Whether to automatically restart the process if it exits
         */
        enabled: z.ZodOptional<z.ZodBoolean>;
        /**
         * Maximum number of restart attempts
         */
        maxAttempts: z.ZodOptional<z.ZodNumber>;
        /**
         * Delay in milliseconds between restart attempts
         */
        delayMs: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        enabled?: boolean | undefined;
        maxAttempts?: number | undefined;
        delayMs?: number | undefined;
    }, {
        enabled?: boolean | undefined;
        maxAttempts?: number | undefined;
        delayMs?: number | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    command: string;
    args: string[];
    stderr: "overlapped" | "pipe" | "ignore" | "inherit";
    type?: "stdio" | undefined;
    transport?: "stdio" | undefined;
    env?: Record<string, string> | undefined;
    encoding?: string | undefined;
    cwd?: string | undefined;
    restart?: {
        enabled?: boolean | undefined;
        maxAttempts?: number | undefined;
        delayMs?: number | undefined;
    } | undefined;
}, {
    command: string;
    args: string[];
    type?: "stdio" | undefined;
    transport?: "stdio" | undefined;
    env?: Record<string, string> | undefined;
    encoding?: string | undefined;
    stderr?: "overlapped" | "pipe" | "ignore" | "inherit" | undefined;
    cwd?: string | undefined;
    restart?: {
        enabled?: boolean | undefined;
        maxAttempts?: number | undefined;
        delayMs?: number | undefined;
    } | undefined;
}>, z.ZodObject<{
    /**
     * Defines where to place each tool output type in the LangChain ToolMessage.
     *
     * Can be set to `content` or `artifact` to send all tool output into the ToolMessage.content or
     * ToolMessage.artifact array, respectively, or you can assign an object that maps each content type
     * to `content` or `artifact`.
     *
     * @default {
     *   "text": "content",
     *   "image": "content",
     *   "audio": "content",
     *   "resource": "artifact"
     * }
     *
     * Items in the `content` field will be used as input context for the LLM, while the artifact field is
     * used for capturing tool output that won't be shown to the model, to be used in some later workflow
     * step.
     *
     * For example, imagine that you have a SQL query tool that can return huge result sets. Rather than
     * sending these large outputs directly to the model, perhaps you want the model to be able to inspect
     * the output in a code execution environment. In this case, you would set the output handling for the
     * `resource` type to `artifact` (its default value), and then upon initialization of your code
     * execution environment, you would look through your message history for `ToolMessage`s with the
     * `artifact` field set to `resource`, and use the `content` field during initialization of the
     * environment.
     */
    outputHandling: z.ZodOptional<z.ZodUnion<[z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>, z.ZodObject<{
        text: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
        image: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
        audio: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
        resource: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
    }, "strip", z.ZodTypeAny, {
        text?: "content" | "artifact" | undefined;
        image?: "content" | "artifact" | undefined;
        audio?: "content" | "artifact" | undefined;
        resource?: "content" | "artifact" | undefined;
    }, {
        text?: "content" | "artifact" | undefined;
        image?: "content" | "artifact" | undefined;
        audio?: "content" | "artifact" | undefined;
        resource?: "content" | "artifact" | undefined;
    }>]>>;
    /**
     * Default timeout in milliseconds for tool execution. Must be greater than 0.
     * If not specified, tools will use their own configured timeout values.
     */
    defaultToolTimeout: z.ZodOptional<z.ZodNumber>;
}, "strip", z.ZodTypeAny, {
    outputHandling?: "content" | "artifact" | {
        text?: "content" | "artifact" | undefined;
        image?: "content" | "artifact" | undefined;
        audio?: "content" | "artifact" | undefined;
        resource?: "content" | "artifact" | undefined;
    } | undefined;
    defaultToolTimeout?: number | undefined;
}, {
    outputHandling?: "content" | "artifact" | {
        text?: "content" | "artifact" | undefined;
        image?: "content" | "artifact" | undefined;
        audio?: "content" | "artifact" | undefined;
        resource?: "content" | "artifact" | undefined;
    } | undefined;
    defaultToolTimeout?: number | undefined;
}>>;
/**
 * Streamable HTTP transport reconnection configuration
 */
export declare const streamableHttpReconnectSchema: z.ZodObject<{
    /**
     * Whether to automatically reconnect if the connection is lost
     */
    enabled: z.ZodOptional<z.ZodBoolean>;
    /**
     * Maximum number of reconnection attempts
     */
    maxAttempts: z.ZodOptional<z.ZodNumber>;
    /**
     * Delay in milliseconds between reconnection attempts
     */
    delayMs: z.ZodOptional<z.ZodNumber>;
}, "strip", z.ZodTypeAny, {
    enabled?: boolean | undefined;
    maxAttempts?: number | undefined;
    delayMs?: number | undefined;
}, {
    enabled?: boolean | undefined;
    maxAttempts?: number | undefined;
    delayMs?: number | undefined;
}>;
/**
 * Streamable HTTP transport connection
 */
export declare const streamableHttpConnectionSchema: z.ZodIntersection<z.ZodObject<{
    /**
     * Optional transport type, inferred from the structure of the config. If "sse", will not attempt
     * to connect using streamable HTTP.
     */
    transport: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"http">, z.ZodLiteral<"sse">]>>;
    /**
     * Optional transport type, inferred from the structure of the config. If "sse", will not attempt
     * to connect using streamable HTTP.
     */
    type: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"http">, z.ZodLiteral<"sse">]>>;
    /**
     * The URL to connect to
     */
    url: z.ZodString;
    /**
     * Additional headers to send with the request, useful for authentication
     */
    headers: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
    /**
     * OAuth client provider for automatic authentication handling.
     * When provided, the transport will automatically handle token refresh,
     * 401 error retries, and OAuth 2.0 flows according to RFC 6750.
     * This is the recommended approach for authentication instead of manual headers.
     */
    authProvider: z.ZodOptional<z.ZodType<OAuthClientProvider, z.ZodTypeDef, OAuthClientProvider>>;
    /**
     * Additional reconnection settings.
     */
    reconnect: z.ZodOptional<z.ZodObject<{
        /**
         * Whether to automatically reconnect if the connection is lost
         */
        enabled: z.ZodOptional<z.ZodBoolean>;
        /**
         * Maximum number of reconnection attempts
         */
        maxAttempts: z.ZodOptional<z.ZodNumber>;
        /**
         * Delay in milliseconds between reconnection attempts
         */
        delayMs: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        enabled?: boolean | undefined;
        maxAttempts?: number | undefined;
        delayMs?: number | undefined;
    }, {
        enabled?: boolean | undefined;
        maxAttempts?: number | undefined;
        delayMs?: number | undefined;
    }>>;
    /**
     * Whether to automatically fallback to SSE if Streamable HTTP is not available or not supported
     *
     * @default true
     */
    automaticSSEFallback: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;
}, "strip", z.ZodTypeAny, {
    url: string;
    automaticSSEFallback: boolean;
    type?: "http" | "sse" | undefined;
    transport?: "http" | "sse" | undefined;
    headers?: Record<string, string> | undefined;
    authProvider?: OAuthClientProvider | undefined;
    reconnect?: {
        enabled?: boolean | undefined;
        maxAttempts?: number | undefined;
        delayMs?: number | undefined;
    } | undefined;
}, {
    url: string;
    type?: "http" | "sse" | undefined;
    transport?: "http" | "sse" | undefined;
    headers?: Record<string, string> | undefined;
    authProvider?: OAuthClientProvider | undefined;
    reconnect?: {
        enabled?: boolean | undefined;
        maxAttempts?: number | undefined;
        delayMs?: number | undefined;
    } | undefined;
    automaticSSEFallback?: boolean | undefined;
}>, z.ZodObject<{
    /**
     * Defines where to place each tool output type in the LangChain ToolMessage.
     *
     * Can be set to `content` or `artifact` to send all tool output into the ToolMessage.content or
     * ToolMessage.artifact array, respectively, or you can assign an object that maps each content type
     * to `content` or `artifact`.
     *
     * @default {
     *   "text": "content",
     *   "image": "content",
     *   "audio": "content",
     *   "resource": "artifact"
     * }
     *
     * Items in the `content` field will be used as input context for the LLM, while the artifact field is
     * used for capturing tool output that won't be shown to the model, to be used in some later workflow
     * step.
     *
     * For example, imagine that you have a SQL query tool that can return huge result sets. Rather than
     * sending these large outputs directly to the model, perhaps you want the model to be able to inspect
     * the output in a code execution environment. In this case, you would set the output handling for the
     * `resource` type to `artifact` (its default value), and then upon initialization of your code
     * execution environment, you would look through your message history for `ToolMessage`s with the
     * `artifact` field set to `resource`, and use the `content` field during initialization of the
     * environment.
     */
    outputHandling: z.ZodOptional<z.ZodUnion<[z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>, z.ZodObject<{
        text: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
        image: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
        audio: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
        resource: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
    }, "strip", z.ZodTypeAny, {
        text?: "content" | "artifact" | undefined;
        image?: "content" | "artifact" | undefined;
        audio?: "content" | "artifact" | undefined;
        resource?: "content" | "artifact" | undefined;
    }, {
        text?: "content" | "artifact" | undefined;
        image?: "content" | "artifact" | undefined;
        audio?: "content" | "artifact" | undefined;
        resource?: "content" | "artifact" | undefined;
    }>]>>;
    /**
     * Default timeout in milliseconds for tool execution. Must be greater than 0.
     * If not specified, tools will use their own configured timeout values.
     */
    defaultToolTimeout: z.ZodOptional<z.ZodNumber>;
}, "strip", z.ZodTypeAny, {
    outputHandling?: "content" | "artifact" | {
        text?: "content" | "artifact" | undefined;
        image?: "content" | "artifact" | undefined;
        audio?: "content" | "artifact" | undefined;
        resource?: "content" | "artifact" | undefined;
    } | undefined;
    defaultToolTimeout?: number | undefined;
}, {
    outputHandling?: "content" | "artifact" | {
        text?: "content" | "artifact" | undefined;
        image?: "content" | "artifact" | undefined;
        audio?: "content" | "artifact" | undefined;
        resource?: "content" | "artifact" | undefined;
    } | undefined;
    defaultToolTimeout?: number | undefined;
}>>;
/**
 * Create combined schema for all transport connection types
 */
export declare const connectionSchema: z.ZodUnion<[z.ZodIntersection<z.ZodObject<{
    /**
     * Optional transport type, inferred from the structure of the config if not provided. Included
     * for compatibility with common MCP client config file formats.
     */
    transport: z.ZodOptional<z.ZodLiteral<"stdio">>;
    /**
     * Optional transport type, inferred from the structure of the config if not provided. Included
     * for compatibility with common MCP client config file formats.
     */
    type: z.ZodOptional<z.ZodLiteral<"stdio">>;
    /**
     * The executable to run the server (e.g. `node`, `npx`, etc)
     */
    command: z.ZodString;
    /**
     * Array of command line arguments to pass to the executable
     */
    args: z.ZodArray<z.ZodString, "many">;
    /**
     * Environment variables to set when spawning the process.
     */
    env: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
    /**
     * The encoding to use when reading from the process
     */
    encoding: z.ZodOptional<z.ZodString>;
    /**
     * How to handle stderr of the child process. This matches the semantics of Node's `child_process.spawn`
     *
     * The default is "inherit", meaning messages to stderr will be printed to the parent process's stderr.
     *
     * @default "inherit"
     */
    stderr: z.ZodDefault<z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"overlapped">, z.ZodLiteral<"pipe">, z.ZodLiteral<"ignore">, z.ZodLiteral<"inherit">]>>>;
    /**
     * The working directory to use when spawning the process.
     */
    cwd: z.ZodOptional<z.ZodString>;
    /**
     * Additional restart settings
     */
    restart: z.ZodOptional<z.ZodObject<{
        /**
         * Whether to automatically restart the process if it exits
         */
        enabled: z.ZodOptional<z.ZodBoolean>;
        /**
         * Maximum number of restart attempts
         */
        maxAttempts: z.ZodOptional<z.ZodNumber>;
        /**
         * Delay in milliseconds between restart attempts
         */
        delayMs: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        enabled?: boolean | undefined;
        maxAttempts?: number | undefined;
        delayMs?: number | undefined;
    }, {
        enabled?: boolean | undefined;
        maxAttempts?: number | undefined;
        delayMs?: number | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    command: string;
    args: string[];
    stderr: "overlapped" | "pipe" | "ignore" | "inherit";
    type?: "stdio" | undefined;
    transport?: "stdio" | undefined;
    env?: Record<string, string> | undefined;
    encoding?: string | undefined;
    cwd?: string | undefined;
    restart?: {
        enabled?: boolean | undefined;
        maxAttempts?: number | undefined;
        delayMs?: number | undefined;
    } | undefined;
}, {
    command: string;
    args: string[];
    type?: "stdio" | undefined;
    transport?: "stdio" | undefined;
    env?: Record<string, string> | undefined;
    encoding?: string | undefined;
    stderr?: "overlapped" | "pipe" | "ignore" | "inherit" | undefined;
    cwd?: string | undefined;
    restart?: {
        enabled?: boolean | undefined;
        maxAttempts?: number | undefined;
        delayMs?: number | undefined;
    } | undefined;
}>, z.ZodObject<{
    /**
     * Defines where to place each tool output type in the LangChain ToolMessage.
     *
     * Can be set to `content` or `artifact` to send all tool output into the ToolMessage.content or
     * ToolMessage.artifact array, respectively, or you can assign an object that maps each content type
     * to `content` or `artifact`.
     *
     * @default {
     *   "text": "content",
     *   "image": "content",
     *   "audio": "content",
     *   "resource": "artifact"
     * }
     *
     * Items in the `content` field will be used as input context for the LLM, while the artifact field is
     * used for capturing tool output that won't be shown to the model, to be used in some later workflow
     * step.
     *
     * For example, imagine that you have a SQL query tool that can return huge result sets. Rather than
     * sending these large outputs directly to the model, perhaps you want the model to be able to inspect
     * the output in a code execution environment. In this case, you would set the output handling for the
     * `resource` type to `artifact` (its default value), and then upon initialization of your code
     * execution environment, you would look through your message history for `ToolMessage`s with the
     * `artifact` field set to `resource`, and use the `content` field during initialization of the
     * environment.
     */
    outputHandling: z.ZodOptional<z.ZodUnion<[z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>, z.ZodObject<{
        text: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
        image: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
        audio: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
        resource: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
    }, "strip", z.ZodTypeAny, {
        text?: "content" | "artifact" | undefined;
        image?: "content" | "artifact" | undefined;
        audio?: "content" | "artifact" | undefined;
        resource?: "content" | "artifact" | undefined;
    }, {
        text?: "content" | "artifact" | undefined;
        image?: "content" | "artifact" | undefined;
        audio?: "content" | "artifact" | undefined;
        resource?: "content" | "artifact" | undefined;
    }>]>>;
    /**
     * Default timeout in milliseconds for tool execution. Must be greater than 0.
     * If not specified, tools will use their own configured timeout values.
     */
    defaultToolTimeout: z.ZodOptional<z.ZodNumber>;
}, "strip", z.ZodTypeAny, {
    outputHandling?: "content" | "artifact" | {
        text?: "content" | "artifact" | undefined;
        image?: "content" | "artifact" | undefined;
        audio?: "content" | "artifact" | undefined;
        resource?: "content" | "artifact" | undefined;
    } | undefined;
    defaultToolTimeout?: number | undefined;
}, {
    outputHandling?: "content" | "artifact" | {
        text?: "content" | "artifact" | undefined;
        image?: "content" | "artifact" | undefined;
        audio?: "content" | "artifact" | undefined;
        resource?: "content" | "artifact" | undefined;
    } | undefined;
    defaultToolTimeout?: number | undefined;
}>>, z.ZodIntersection<z.ZodObject<{
    /**
     * Optional transport type, inferred from the structure of the config. If "sse", will not attempt
     * to connect using streamable HTTP.
     */
    transport: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"http">, z.ZodLiteral<"sse">]>>;
    /**
     * Optional transport type, inferred from the structure of the config. If "sse", will not attempt
     * to connect using streamable HTTP.
     */
    type: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"http">, z.ZodLiteral<"sse">]>>;
    /**
     * The URL to connect to
     */
    url: z.ZodString;
    /**
     * Additional headers to send with the request, useful for authentication
     */
    headers: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
    /**
     * OAuth client provider for automatic authentication handling.
     * When provided, the transport will automatically handle token refresh,
     * 401 error retries, and OAuth 2.0 flows according to RFC 6750.
     * This is the recommended approach for authentication instead of manual headers.
     */
    authProvider: z.ZodOptional<z.ZodType<OAuthClientProvider, z.ZodTypeDef, OAuthClientProvider>>;
    /**
     * Additional reconnection settings.
     */
    reconnect: z.ZodOptional<z.ZodObject<{
        /**
         * Whether to automatically reconnect if the connection is lost
         */
        enabled: z.ZodOptional<z.ZodBoolean>;
        /**
         * Maximum number of reconnection attempts
         */
        maxAttempts: z.ZodOptional<z.ZodNumber>;
        /**
         * Delay in milliseconds between reconnection attempts
         */
        delayMs: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        enabled?: boolean | undefined;
        maxAttempts?: number | undefined;
        delayMs?: number | undefined;
    }, {
        enabled?: boolean | undefined;
        maxAttempts?: number | undefined;
        delayMs?: number | undefined;
    }>>;
    /**
     * Whether to automatically fallback to SSE if Streamable HTTP is not available or not supported
     *
     * @default true
     */
    automaticSSEFallback: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;
}, "strip", z.ZodTypeAny, {
    url: string;
    automaticSSEFallback: boolean;
    type?: "http" | "sse" | undefined;
    transport?: "http" | "sse" | undefined;
    headers?: Record<string, string> | undefined;
    authProvider?: OAuthClientProvider | undefined;
    reconnect?: {
        enabled?: boolean | undefined;
        maxAttempts?: number | undefined;
        delayMs?: number | undefined;
    } | undefined;
}, {
    url: string;
    type?: "http" | "sse" | undefined;
    transport?: "http" | "sse" | undefined;
    headers?: Record<string, string> | undefined;
    authProvider?: OAuthClientProvider | undefined;
    reconnect?: {
        enabled?: boolean | undefined;
        maxAttempts?: number | undefined;
        delayMs?: number | undefined;
    } | undefined;
    automaticSSEFallback?: boolean | undefined;
}>, z.ZodObject<{
    /**
     * Defines where to place each tool output type in the LangChain ToolMessage.
     *
     * Can be set to `content` or `artifact` to send all tool output into the ToolMessage.content or
     * ToolMessage.artifact array, respectively, or you can assign an object that maps each content type
     * to `content` or `artifact`.
     *
     * @default {
     *   "text": "content",
     *   "image": "content",
     *   "audio": "content",
     *   "resource": "artifact"
     * }
     *
     * Items in the `content` field will be used as input context for the LLM, while the artifact field is
     * used for capturing tool output that won't be shown to the model, to be used in some later workflow
     * step.
     *
     * For example, imagine that you have a SQL query tool that can return huge result sets. Rather than
     * sending these large outputs directly to the model, perhaps you want the model to be able to inspect
     * the output in a code execution environment. In this case, you would set the output handling for the
     * `resource` type to `artifact` (its default value), and then upon initialization of your code
     * execution environment, you would look through your message history for `ToolMessage`s with the
     * `artifact` field set to `resource`, and use the `content` field during initialization of the
     * environment.
     */
    outputHandling: z.ZodOptional<z.ZodUnion<[z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>, z.ZodObject<{
        text: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
        image: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
        audio: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
        resource: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
    }, "strip", z.ZodTypeAny, {
        text?: "content" | "artifact" | undefined;
        image?: "content" | "artifact" | undefined;
        audio?: "content" | "artifact" | undefined;
        resource?: "content" | "artifact" | undefined;
    }, {
        text?: "content" | "artifact" | undefined;
        image?: "content" | "artifact" | undefined;
        audio?: "content" | "artifact" | undefined;
        resource?: "content" | "artifact" | undefined;
    }>]>>;
    /**
     * Default timeout in milliseconds for tool execution. Must be greater than 0.
     * If not specified, tools will use their own configured timeout values.
     */
    defaultToolTimeout: z.ZodOptional<z.ZodNumber>;
}, "strip", z.ZodTypeAny, {
    outputHandling?: "content" | "artifact" | {
        text?: "content" | "artifact" | undefined;
        image?: "content" | "artifact" | undefined;
        audio?: "content" | "artifact" | undefined;
        resource?: "content" | "artifact" | undefined;
    } | undefined;
    defaultToolTimeout?: number | undefined;
}, {
    outputHandling?: "content" | "artifact" | {
        text?: "content" | "artifact" | undefined;
        image?: "content" | "artifact" | undefined;
        audio?: "content" | "artifact" | undefined;
        resource?: "content" | "artifact" | undefined;
    } | undefined;
    defaultToolTimeout?: number | undefined;
}>>]>;
/**
 * {@link MultiServerMCPClient} configuration
 */
export declare const clientConfigSchema: z.ZodIntersection<z.ZodObject<{
    /**
     * A map of server names to their configuration
     */
    mcpServers: z.ZodRecord<z.ZodString, z.ZodUnion<[z.ZodIntersection<z.ZodObject<{
        /**
         * Optional transport type, inferred from the structure of the config if not provided. Included
         * for compatibility with common MCP client config file formats.
         */
        transport: z.ZodOptional<z.ZodLiteral<"stdio">>;
        /**
         * Optional transport type, inferred from the structure of the config if not provided. Included
         * for compatibility with common MCP client config file formats.
         */
        type: z.ZodOptional<z.ZodLiteral<"stdio">>;
        /**
         * The executable to run the server (e.g. `node`, `npx`, etc)
         */
        command: z.ZodString;
        /**
         * Array of command line arguments to pass to the executable
         */
        args: z.ZodArray<z.ZodString, "many">;
        /**
         * Environment variables to set when spawning the process.
         */
        env: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
        /**
         * The encoding to use when reading from the process
         */
        encoding: z.ZodOptional<z.ZodString>;
        /**
         * How to handle stderr of the child process. This matches the semantics of Node's `child_process.spawn`
         *
         * The default is "inherit", meaning messages to stderr will be printed to the parent process's stderr.
         *
         * @default "inherit"
         */
        stderr: z.ZodDefault<z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"overlapped">, z.ZodLiteral<"pipe">, z.ZodLiteral<"ignore">, z.ZodLiteral<"inherit">]>>>;
        /**
         * The working directory to use when spawning the process.
         */
        cwd: z.ZodOptional<z.ZodString>;
        /**
         * Additional restart settings
         */
        restart: z.ZodOptional<z.ZodObject<{
            /**
             * Whether to automatically restart the process if it exits
             */
            enabled: z.ZodOptional<z.ZodBoolean>;
            /**
             * Maximum number of restart attempts
             */
            maxAttempts: z.ZodOptional<z.ZodNumber>;
            /**
             * Delay in milliseconds between restart attempts
             */
            delayMs: z.ZodOptional<z.ZodNumber>;
        }, "strip", z.ZodTypeAny, {
            enabled?: boolean | undefined;
            maxAttempts?: number | undefined;
            delayMs?: number | undefined;
        }, {
            enabled?: boolean | undefined;
            maxAttempts?: number | undefined;
            delayMs?: number | undefined;
        }>>;
    }, "strip", z.ZodTypeAny, {
        command: string;
        args: string[];
        stderr: "overlapped" | "pipe" | "ignore" | "inherit";
        type?: "stdio" | undefined;
        transport?: "stdio" | undefined;
        env?: Record<string, string> | undefined;
        encoding?: string | undefined;
        cwd?: string | undefined;
        restart?: {
            enabled?: boolean | undefined;
            maxAttempts?: number | undefined;
            delayMs?: number | undefined;
        } | undefined;
    }, {
        command: string;
        args: string[];
        type?: "stdio" | undefined;
        transport?: "stdio" | undefined;
        env?: Record<string, string> | undefined;
        encoding?: string | undefined;
        stderr?: "overlapped" | "pipe" | "ignore" | "inherit" | undefined;
        cwd?: string | undefined;
        restart?: {
            enabled?: boolean | undefined;
            maxAttempts?: number | undefined;
            delayMs?: number | undefined;
        } | undefined;
    }>, z.ZodObject<{
        /**
         * Defines where to place each tool output type in the LangChain ToolMessage.
         *
         * Can be set to `content` or `artifact` to send all tool output into the ToolMessage.content or
         * ToolMessage.artifact array, respectively, or you can assign an object that maps each content type
         * to `content` or `artifact`.
         *
         * @default {
         *   "text": "content",
         *   "image": "content",
         *   "audio": "content",
         *   "resource": "artifact"
         * }
         *
         * Items in the `content` field will be used as input context for the LLM, while the artifact field is
         * used for capturing tool output that won't be shown to the model, to be used in some later workflow
         * step.
         *
         * For example, imagine that you have a SQL query tool that can return huge result sets. Rather than
         * sending these large outputs directly to the model, perhaps you want the model to be able to inspect
         * the output in a code execution environment. In this case, you would set the output handling for the
         * `resource` type to `artifact` (its default value), and then upon initialization of your code
         * execution environment, you would look through your message history for `ToolMessage`s with the
         * `artifact` field set to `resource`, and use the `content` field during initialization of the
         * environment.
         */
        outputHandling: z.ZodOptional<z.ZodUnion<[z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>, z.ZodObject<{
            text: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
            image: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
            audio: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
            resource: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
        }, "strip", z.ZodTypeAny, {
            text?: "content" | "artifact" | undefined;
            image?: "content" | "artifact" | undefined;
            audio?: "content" | "artifact" | undefined;
            resource?: "content" | "artifact" | undefined;
        }, {
            text?: "content" | "artifact" | undefined;
            image?: "content" | "artifact" | undefined;
            audio?: "content" | "artifact" | undefined;
            resource?: "content" | "artifact" | undefined;
        }>]>>;
        /**
         * Default timeout in milliseconds for tool execution. Must be greater than 0.
         * If not specified, tools will use their own configured timeout values.
         */
        defaultToolTimeout: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        outputHandling?: "content" | "artifact" | {
            text?: "content" | "artifact" | undefined;
            image?: "content" | "artifact" | undefined;
            audio?: "content" | "artifact" | undefined;
            resource?: "content" | "artifact" | undefined;
        } | undefined;
        defaultToolTimeout?: number | undefined;
    }, {
        outputHandling?: "content" | "artifact" | {
            text?: "content" | "artifact" | undefined;
            image?: "content" | "artifact" | undefined;
            audio?: "content" | "artifact" | undefined;
            resource?: "content" | "artifact" | undefined;
        } | undefined;
        defaultToolTimeout?: number | undefined;
    }>>, z.ZodIntersection<z.ZodObject<{
        /**
         * Optional transport type, inferred from the structure of the config. If "sse", will not attempt
         * to connect using streamable HTTP.
         */
        transport: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"http">, z.ZodLiteral<"sse">]>>;
        /**
         * Optional transport type, inferred from the structure of the config. If "sse", will not attempt
         * to connect using streamable HTTP.
         */
        type: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"http">, z.ZodLiteral<"sse">]>>;
        /**
         * The URL to connect to
         */
        url: z.ZodString;
        /**
         * Additional headers to send with the request, useful for authentication
         */
        headers: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
        /**
         * OAuth client provider for automatic authentication handling.
         * When provided, the transport will automatically handle token refresh,
         * 401 error retries, and OAuth 2.0 flows according to RFC 6750.
         * This is the recommended approach for authentication instead of manual headers.
         */
        authProvider: z.ZodOptional<z.ZodType<OAuthClientProvider, z.ZodTypeDef, OAuthClientProvider>>;
        /**
         * Additional reconnection settings.
         */
        reconnect: z.ZodOptional<z.ZodObject<{
            /**
             * Whether to automatically reconnect if the connection is lost
             */
            enabled: z.ZodOptional<z.ZodBoolean>;
            /**
             * Maximum number of reconnection attempts
             */
            maxAttempts: z.ZodOptional<z.ZodNumber>;
            /**
             * Delay in milliseconds between reconnection attempts
             */
            delayMs: z.ZodOptional<z.ZodNumber>;
        }, "strip", z.ZodTypeAny, {
            enabled?: boolean | undefined;
            maxAttempts?: number | undefined;
            delayMs?: number | undefined;
        }, {
            enabled?: boolean | undefined;
            maxAttempts?: number | undefined;
            delayMs?: number | undefined;
        }>>;
        /**
         * Whether to automatically fallback to SSE if Streamable HTTP is not available or not supported
         *
         * @default true
         */
        automaticSSEFallback: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;
    }, "strip", z.ZodTypeAny, {
        url: string;
        automaticSSEFallback: boolean;
        type?: "http" | "sse" | undefined;
        transport?: "http" | "sse" | undefined;
        headers?: Record<string, string> | undefined;
        authProvider?: OAuthClientProvider | undefined;
        reconnect?: {
            enabled?: boolean | undefined;
            maxAttempts?: number | undefined;
            delayMs?: number | undefined;
        } | undefined;
    }, {
        url: string;
        type?: "http" | "sse" | undefined;
        transport?: "http" | "sse" | undefined;
        headers?: Record<string, string> | undefined;
        authProvider?: OAuthClientProvider | undefined;
        reconnect?: {
            enabled?: boolean | undefined;
            maxAttempts?: number | undefined;
            delayMs?: number | undefined;
        } | undefined;
        automaticSSEFallback?: boolean | undefined;
    }>, z.ZodObject<{
        /**
         * Defines where to place each tool output type in the LangChain ToolMessage.
         *
         * Can be set to `content` or `artifact` to send all tool output into the ToolMessage.content or
         * ToolMessage.artifact array, respectively, or you can assign an object that maps each content type
         * to `content` or `artifact`.
         *
         * @default {
         *   "text": "content",
         *   "image": "content",
         *   "audio": "content",
         *   "resource": "artifact"
         * }
         *
         * Items in the `content` field will be used as input context for the LLM, while the artifact field is
         * used for capturing tool output that won't be shown to the model, to be used in some later workflow
         * step.
         *
         * For example, imagine that you have a SQL query tool that can return huge result sets. Rather than
         * sending these large outputs directly to the model, perhaps you want the model to be able to inspect
         * the output in a code execution environment. In this case, you would set the output handling for the
         * `resource` type to `artifact` (its default value), and then upon initialization of your code
         * execution environment, you would look through your message history for `ToolMessage`s with the
         * `artifact` field set to `resource`, and use the `content` field during initialization of the
         * environment.
         */
        outputHandling: z.ZodOptional<z.ZodUnion<[z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>, z.ZodObject<{
            text: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
            image: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
            audio: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
            resource: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
        }, "strip", z.ZodTypeAny, {
            text?: "content" | "artifact" | undefined;
            image?: "content" | "artifact" | undefined;
            audio?: "content" | "artifact" | undefined;
            resource?: "content" | "artifact" | undefined;
        }, {
            text?: "content" | "artifact" | undefined;
            image?: "content" | "artifact" | undefined;
            audio?: "content" | "artifact" | undefined;
            resource?: "content" | "artifact" | undefined;
        }>]>>;
        /**
         * Default timeout in milliseconds for tool execution. Must be greater than 0.
         * If not specified, tools will use their own configured timeout values.
         */
        defaultToolTimeout: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        outputHandling?: "content" | "artifact" | {
            text?: "content" | "artifact" | undefined;
            image?: "content" | "artifact" | undefined;
            audio?: "content" | "artifact" | undefined;
            resource?: "content" | "artifact" | undefined;
        } | undefined;
        defaultToolTimeout?: number | undefined;
    }, {
        outputHandling?: "content" | "artifact" | {
            text?: "content" | "artifact" | undefined;
            image?: "content" | "artifact" | undefined;
            audio?: "content" | "artifact" | undefined;
            resource?: "content" | "artifact" | undefined;
        } | undefined;
        defaultToolTimeout?: number | undefined;
    }>>]>>;
    /**
     * Whether to throw an error if a tool fails to load
     *
     * @default true
     */
    throwOnLoadError: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;
    /**
     * Whether to prefix tool names with the server name. Prefixes are separated by double
     * underscores (example: `calculator_server_1__add`).
     *
     * @default true
     */
    prefixToolNameWithServerName: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;
    /**
     * An additional prefix to add to the tool name Prefixes are separated by double underscores
     * (example: `mcp__add`).
     *
     * @default "mcp"
     */
    additionalToolNamePrefix: z.ZodDefault<z.ZodOptional<z.ZodString>>;
    /**
     * If true, the tool will use LangChain's standard multimodal content blocks for tools that output
     * image or audio content, and embedded resources will be converted to `StandardFileBlock` objects.
     * When `false`, all artifacts are left in their MCP format, but embedded resources will be
     * converted to `StandardFileBlock` objects if {@link ClientConfig#outputHandling} causes embedded resources to
     * be treated as content, as otherwise ChatModel providers will not be able to interpret them.
     *
     * @default false
     */
    useStandardContentBlocks: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;
}, "strip", z.ZodTypeAny, {
    mcpServers: Record<string, ({
        command: string;
        args: string[];
        stderr: "overlapped" | "pipe" | "ignore" | "inherit";
        type?: "stdio" | undefined;
        transport?: "stdio" | undefined;
        env?: Record<string, string> | undefined;
        encoding?: string | undefined;
        cwd?: string | undefined;
        restart?: {
            enabled?: boolean | undefined;
            maxAttempts?: number | undefined;
            delayMs?: number | undefined;
        } | undefined;
    } & {
        outputHandling?: "content" | "artifact" | {
            text?: "content" | "artifact" | undefined;
            image?: "content" | "artifact" | undefined;
            audio?: "content" | "artifact" | undefined;
            resource?: "content" | "artifact" | undefined;
        } | undefined;
        defaultToolTimeout?: number | undefined;
    }) | ({
        url: string;
        automaticSSEFallback: boolean;
        type?: "http" | "sse" | undefined;
        transport?: "http" | "sse" | undefined;
        headers?: Record<string, string> | undefined;
        authProvider?: OAuthClientProvider | undefined;
        reconnect?: {
            enabled?: boolean | undefined;
            maxAttempts?: number | undefined;
            delayMs?: number | undefined;
        } | undefined;
    } & {
        outputHandling?: "content" | "artifact" | {
            text?: "content" | "artifact" | undefined;
            image?: "content" | "artifact" | undefined;
            audio?: "content" | "artifact" | undefined;
            resource?: "content" | "artifact" | undefined;
        } | undefined;
        defaultToolTimeout?: number | undefined;
    })>;
    throwOnLoadError: boolean;
    prefixToolNameWithServerName: boolean;
    additionalToolNamePrefix: string;
    useStandardContentBlocks: boolean;
}, {
    mcpServers: Record<string, ({
        command: string;
        args: string[];
        type?: "stdio" | undefined;
        transport?: "stdio" | undefined;
        env?: Record<string, string> | undefined;
        encoding?: string | undefined;
        stderr?: "overlapped" | "pipe" | "ignore" | "inherit" | undefined;
        cwd?: string | undefined;
        restart?: {
            enabled?: boolean | undefined;
            maxAttempts?: number | undefined;
            delayMs?: number | undefined;
        } | undefined;
    } & {
        outputHandling?: "content" | "artifact" | {
            text?: "content" | "artifact" | undefined;
            image?: "content" | "artifact" | undefined;
            audio?: "content" | "artifact" | undefined;
            resource?: "content" | "artifact" | undefined;
        } | undefined;
        defaultToolTimeout?: number | undefined;
    }) | ({
        url: string;
        type?: "http" | "sse" | undefined;
        transport?: "http" | "sse" | undefined;
        headers?: Record<string, string> | undefined;
        authProvider?: OAuthClientProvider | undefined;
        reconnect?: {
            enabled?: boolean | undefined;
            maxAttempts?: number | undefined;
            delayMs?: number | undefined;
        } | undefined;
        automaticSSEFallback?: boolean | undefined;
    } & {
        outputHandling?: "content" | "artifact" | {
            text?: "content" | "artifact" | undefined;
            image?: "content" | "artifact" | undefined;
            audio?: "content" | "artifact" | undefined;
            resource?: "content" | "artifact" | undefined;
        } | undefined;
        defaultToolTimeout?: number | undefined;
    })>;
    throwOnLoadError?: boolean | undefined;
    prefixToolNameWithServerName?: boolean | undefined;
    additionalToolNamePrefix?: string | undefined;
    useStandardContentBlocks?: boolean | undefined;
}>, z.ZodObject<{
    /**
     * Defines where to place each tool output type in the LangChain ToolMessage.
     *
     * Can be set to `content` or `artifact` to send all tool output into the ToolMessage.content or
     * ToolMessage.artifact array, respectively, or you can assign an object that maps each content type
     * to `content` or `artifact`.
     *
     * @default {
     *   "text": "content",
     *   "image": "content",
     *   "audio": "content",
     *   "resource": "artifact"
     * }
     *
     * Items in the `content` field will be used as input context for the LLM, while the artifact field is
     * used for capturing tool output that won't be shown to the model, to be used in some later workflow
     * step.
     *
     * For example, imagine that you have a SQL query tool that can return huge result sets. Rather than
     * sending these large outputs directly to the model, perhaps you want the model to be able to inspect
     * the output in a code execution environment. In this case, you would set the output handling for the
     * `resource` type to `artifact` (its default value), and then upon initialization of your code
     * execution environment, you would look through your message history for `ToolMessage`s with the
     * `artifact` field set to `resource`, and use the `content` field during initialization of the
     * environment.
     */
    outputHandling: z.ZodOptional<z.ZodUnion<[z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>, z.ZodObject<{
        text: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
        image: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
        audio: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
        resource: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"content">, z.ZodLiteral<"artifact">]>>;
    }, "strip", z.ZodTypeAny, {
        text?: "content" | "artifact" | undefined;
        image?: "content" | "artifact" | undefined;
        audio?: "content" | "artifact" | undefined;
        resource?: "content" | "artifact" | undefined;
    }, {
        text?: "content" | "artifact" | undefined;
        image?: "content" | "artifact" | undefined;
        audio?: "content" | "artifact" | undefined;
        resource?: "content" | "artifact" | undefined;
    }>]>>;
    /**
     * Default timeout in milliseconds for tool execution. Must be greater than 0.
     * If not specified, tools will use their own configured timeout values.
     */
    defaultToolTimeout: z.ZodOptional<z.ZodNumber>;
}, "strip", z.ZodTypeAny, {
    outputHandling?: "content" | "artifact" | {
        text?: "content" | "artifact" | undefined;
        image?: "content" | "artifact" | undefined;
        audio?: "content" | "artifact" | undefined;
        resource?: "content" | "artifact" | undefined;
    } | undefined;
    defaultToolTimeout?: number | undefined;
}, {
    outputHandling?: "content" | "artifact" | {
        text?: "content" | "artifact" | undefined;
        image?: "content" | "artifact" | undefined;
        audio?: "content" | "artifact" | undefined;
        resource?: "content" | "artifact" | undefined;
    } | undefined;
    defaultToolTimeout?: number | undefined;
}>>;
/**
 * Configuration for stdio transport connection
 */
export type StdioConnection = z.input<typeof stdioConnectionSchema>;
/**
 * Type for {@link StdioConnection} with default values applied.
 */
export type ResolvedStdioConnection = z.output<typeof stdioConnectionSchema>;
/**
 * Configuration for streamable HTTP transport connection
 */
export type StreamableHTTPConnection = z.input<typeof streamableHttpConnectionSchema>;
/**
 * Type for {@link StreamableHTTPConnection} with default values applied.
 */
export type ResolvedStreamableHTTPConnection = z.output<typeof streamableHttpConnectionSchema>;
/**
 * Union type for all transport connection types
 */
export type Connection = z.input<typeof connectionSchema>;
/**
 * Type for {@link MultiServerMCPClient} configuration
 */
export type ClientConfig = z.input<typeof clientConfigSchema>;
/**
 * Type for {@link Connection} with default values applied.
 */
export type ResolvedConnection = z.output<typeof connectionSchema>;
/**
 * Type for {@link MultiServerMCPClient} configuration, with default values applied.
 */
export type ResolvedClientConfig = z.output<typeof clientConfigSchema>;
export type LoadMcpToolsOptions = {
    /**
     * If true, throw an error if a tool fails to load.
     *
     * @default true
     */
    throwOnLoadError?: boolean;
    /**
     * If true, the tool name will be prefixed with the server name followed by a double underscore.
     * This is useful if you want to avoid tool name collisions across servers.
     *
     * @default false
     */
    prefixToolNameWithServerName?: boolean;
    /**
     * An additional prefix to add to the tool name. Will be added at the very beginning of the tool
     * name, separated by a double underscore.
     *
     * For example, if `additionalToolNamePrefix` is `"mcp"`, and `prefixToolNameWithServerName` is
     * `true`, the tool name `"my-tool"` provided by server `"my-server"` will become
     * `"mcp__my-server__my-tool"`.
     *
     * Similarly, if `additionalToolNamePrefix` is `mcp` and `prefixToolNameWithServerName` is false,
     * the tool name would be `"mcp__my-tool"`.
     *
     * @default ""
     */
    additionalToolNamePrefix?: string;
    /**
     * If true, the tool will use LangChain's standard multimodal content blocks for tools that output
     * image or audio content, and embedded resources will be converted to `StandardFileBlock` objects.
     * When `false`, all artifacts are left in their MCP format, but embedded resources will be
     * converted to `StandardFileBlock` objects if {@link outputHandling} causes embedded resources to
     * be treated as content, as otherwise ChatModel providers will not be able to interpret them.
     *
     * @default false
     */
    useStandardContentBlocks?: boolean;
    /**
     * Defines where to place each tool output type in the LangChain ToolMessage.
     *
     * @default {
     *   "text": "content",
     *   "image": "content",
     *   "audio": "content",
     *   "resource": "artifact"
     * }
     */
    outputHandling?: OutputHandling;
    /**
     * Default timeout in milliseconds for tool execution. Must be greater than 0.
     * If not specified, tools will use their own configured timeout values.
     */
    defaultToolTimeout?: number;
};
/**
 * Helper function that expands a string literal OutputHandling to an object with all content types.
 * Used when applying server-level overrides to the top-level config.
 *
 * @internal
 */
export declare function _resolveDetailedOutputHandling(outputHandling: OutputHandling | undefined, applyDefaults?: boolean): DetailedOutputHandling;
/**
 * Given a base {@link OutputHandling}, apply any overrides from the override {@link OutputHandling}.
 *
 * @internal
 */
export declare function _resolveAndApplyOverrideHandlingOverrides(base: OutputHandling | undefined, override: OutputHandling | undefined): OutputHandling;
